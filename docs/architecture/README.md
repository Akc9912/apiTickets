# üèóÔ∏è Arquitectura del Sistema

Este documento describe la arquitectura completa del sistema ApiTickets, incluyendo patrones de dise√±o, estructura de capas, y decisiones arquitect√≥nicas.

## üìã Tabla de Contenidos

- [üéØ Visi√≥n General](#visi√≥n-general)
- [üèõÔ∏è Patrones Arquitect√≥nicos](#patrones-arquitect√≥nicos)
- [üìê Estructura de Capas](#estructura-de-capas)
- [üóÑÔ∏è Modelo de Datos](#modelo-de-datos)
- [üîÑ Flujos de Datos](#flujos-de-datos)
- [üîê Arquitectura de Seguridad](#arquitectura-de-seguridad)
- [üìä Arquitectura de Analytics](#arquitectura-de-analytics)
- [üöÄ Escalabilidad](#escalabilidad)

---

## üéØ Visi√≥n General

ApiTickets implementa una **arquitectura en capas limpia** combinada con principios de **Domain-Driven Design (DDD)**, proporcionando:

- **Separaci√≥n clara de responsabilidades**
- **Alta cohesi√≥n y bajo acoplamiento**
- **Facilidad de testing y mantenimiento**
- **Escalabilidad horizontal y vertical**
- **Flexibilidad para cambios futuros**

### üé™ Arquitectura de Alto Nivel

```mermaid
graph TB
    Client[Cliente Web/Mobile] --> LB[Load Balancer]
    LB --> App1[App Instance 1]
    LB --> App2[App Instance 2]
    LB --> AppN[App Instance N]

    App1 --> Cache[Redis Cache]
    App2 --> Cache
    AppN --> Cache

    App1 --> DB[(MySQL Primary)]
    App2 --> DB
    AppN --> DB

    DB --> DBR[(MySQL Replica)]

    App1 --> Queue[Message Queue]
    App2 --> Queue
    AppN --> Queue

    Queue --> NotificationService[Notification Service]
    Queue --> AnalyticsService[Analytics Service]

    subgraph Monitoring
        Prometheus[Prometheus]
        Grafana[Grafana]
        ELK[ELK Stack]
    end

    App1 --> Monitoring
    App2 --> Monitoring
    AppN --> Monitoring
```

---

## üèõÔ∏è Patrones Arquitect√≥nicos

### üéØ Clean Architecture

Implementamos **Clean Architecture** con las siguientes caracter√≠sticas:

- **Independencia de frameworks**: El core business no depende de Spring Boot
- **Testabilidad**: Cada capa puede ser probada independientemente
- **Independencia de UI**: La l√≥gica no depende de la interfaz
- **Independencia de base de datos**: Podemos cambiar MySQL por PostgreSQL f√°cilmente

### üé≠ Domain-Driven Design (DDD)

Aplicamos principios DDD:

- **Bounded Contexts**: Cada m√≥dulo tiene su contexto bien definido
- **Aggregates**: Entidades relacionadas se agrupan l√≥gicamente
- **Domain Services**: L√≥gica de negocio compleja se encapsula en servicios
- **Value Objects**: Objetos inmutables para conceptos del dominio

### üì¶ Patr√≥n Repository

```java
// Abstracci√≥n del acceso a datos
public interface TicketRepository extends JpaRepository<Ticket, Integer> {
    // M√©todos de consulta espec√≠ficos del dominio
    List<Ticket> findByEstadoAndTecnicoId(EstadoTicket estado, Integer tecnicoId);
    Page<Ticket> findByUsuarioIdOrderByFechaCreacionDesc(Integer usuarioId, Pageable pageable);
}
```

### üéØ CQRS (Command Query Responsibility Segregation)

Separamos comandos (escritura) de consultas (lectura):

```java
// Comando - Modifica estado
@Service
public class TicketCommandService {
    public void crearTicket(CrearTicketCommand command) { /* ... */ }
    public void asignarTicket(AsignarTicketCommand command) { /* ... */ }
}

// Query - Solo lectura
@Service
public class TicketQueryService {
    public TicketDTO obtenerTicket(Integer id) { /* ... */ }
    public Page<TicketDTO> buscarTickets(BusquedaTicketQuery query) { /* ... */ }
}
```

---

## üìê Estructura de Capas

### üé® Capa de Presentaci√≥n (Presentation Layer)

**Responsabilidades:**
- Manejo de requests HTTP
- Validaci√≥n de entrada
- Serializaci√≥n/Deserializaci√≥n JSON
- Manejo de excepciones
- Documentaci√≥n API (Swagger)

**Componentes:**
```
src/main/java/com/poo/miapi/controller/
‚îú‚îÄ‚îÄ auth/           # Autenticaci√≥n y autorizaci√≥n
‚îú‚îÄ‚îÄ core/           # Operaciones principales
‚îú‚îÄ‚îÄ estadistica/    # Analytics y reportes
‚îú‚îÄ‚îÄ historial/      # Auditor√≠a y logs
‚îî‚îÄ‚îÄ notificacion/   # Sistema de notificaciones
```

**Ejemplo de Controller:**
```java
@RestController
@RequestMapping("/api/v1/tickets")
@SecurityRequirement(name = "JWT")
public class TicketController {

    @Autowired
    private TicketService ticketService;

    @PostMapping
    @PreAuthorize("hasRole('TRABAJADOR')")
    public ResponseEntity<TicketDTO> crearTicket(@Valid @RequestBody CrearTicketRequest request) {
        // Delega a la capa de servicio
        return ResponseEntity.ok(ticketService.crearTicket(request));
    }
}
```

### üß† Capa de Aplicaci√≥n/Servicio (Service Layer)

**Responsabilidades:**
- L√≥gica de negocio
- Coordinaci√≥n entre repositorios
- Validaciones de dominio
- Manejo de transacciones
- Orquestaci√≥n de operaciones complejas

**Estructura:**
```
src/main/java/com/poo/miapi/service/
‚îú‚îÄ‚îÄ core/           # Servicios principales
‚îú‚îÄ‚îÄ auth/           # Servicios de autenticaci√≥n
‚îú‚îÄ‚îÄ estadistica/    # Servicios de analytics
‚îú‚îÄ‚îÄ historial/      # Servicios de auditor√≠a
‚îî‚îÄ‚îÄ notificacion/   # Servicios de notificaci√≥n
```

**Ejemplo de Service:**
```java
@Service
@Transactional
public class TicketService {

    @Autowired
    private TicketRepository ticketRepository;

    @Autowired
    private AuditoriaService auditoriaService;

    @Autowired
    private NotificacionService notificacionService;

    public TicketDTO crearTicket(CrearTicketRequest request) {
        // 1. Validar datos
        validarCreacionTicket(request);

        // 2. Crear entidad
        Ticket ticket = mapperService.toEntity(request);

        // 3. Guardar en BD
        ticket = ticketRepository.save(ticket);

        // 4. Auditar acci√≥n
        auditoriaService.auditarCreacion(ticket);

        // 5. Notificar administradores
        notificacionService.notificarNuevoTicket(ticket);

        // 6. Retornar DTO
        return mapperService.toDTO(ticket);
    }
}
```

### üóÑÔ∏è Capa de Acceso a Datos (Repository Layer)

**Responsabilidades:**
- Acceso a datos
- Consultas optimizadas
- Cach√© de segundo nivel
- Transacciones de datos

**Estructura:**
```
src/main/java/com/poo/miapi/repository/
‚îú‚îÄ‚îÄ core/           # Repositorios principales
‚îú‚îÄ‚îÄ historial/      # Repositorios de auditor√≠a
‚îî‚îÄ‚îÄ custom/         # Consultas personalizadas
```

**Ejemplo de Repository Personalizado:**
```java
@Repository
public class TicketRepositoryCustomImpl implements TicketRepositoryCustom {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<EstadisticaTicketDTO> obtenerEstadisticasPorPeriodo(
            LocalDateTime inicio, LocalDateTime fin) {

        String jpql = """
            SELECT new com.poo.miapi.dto.EstadisticaTicketDTO(
                DATE_FORMAT(t.fechaCreacion, '%Y-%m') as periodo,
                COUNT(t) as total,
                AVG(TIMESTAMPDIFF(HOUR, t.fechaCreacion, t.fechaResolucion)) as tiempoPromedio
            )
            FROM Ticket t
            WHERE t.fechaCreacion BETWEEN :inicio AND :fin
            GROUP BY DATE_FORMAT(t.fechaCreacion, '%Y-%m')
            ORDER BY periodo
            """;

        return entityManager.createQuery(jpql, EstadisticaTicketDTO.class)
                .setParameter("inicio", inicio)
                .setParameter("fin", fin)
                .getResultList();
    }
}
```

### üèõÔ∏è Capa de Dominio (Domain Layer)

**Responsabilidades:**
- Entidades de negocio
- Value Objects
- Enums del dominio
- L√≥gica de dominio pura

**Estructura:**
```
src/main/java/com/poo/miapi/model/
‚îú‚îÄ‚îÄ core/           # Entidades principales
‚îú‚îÄ‚îÄ enums/          # Enumeraciones del dominio
‚îú‚îÄ‚îÄ historial/      # Entidades de auditor√≠a
‚îî‚îÄ‚îÄ notificacion/   # Entidades de notificaci√≥n
```

**Ejemplo de Entidad con L√≥gica de Dominio:**
```java
@Entity
@Table(name = "ticket")
public class Ticket {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @Enumerated(EnumType.STRING)
    private EstadoTicket estado;

    // L√≥gica de dominio
    public void asignarATecnico(Tecnico tecnico) {
        if (this.estado != EstadoTicket.PENDIENTE) {
            throw new IllegalStateException("Solo se pueden asignar tickets pendientes");
        }

        if (tecnico == null || !tecnico.isActivo()) {
            throw new IllegalArgumentException("El t√©cnico debe estar activo");
        }

        this.tecnico = tecnico;
        this.estado = EstadoTicket.ASIGNADO;
        this.fechaAsignacion = LocalDateTime.now();
    }

    public boolean puedeSerResuelto() {
        return this.estado == EstadoTicket.ASIGNADO && this.tecnico != null;
    }

    public Duration getTiempoResolucion() {
        if (fechaCreacion != null && fechaResolucion != null) {
            return Duration.between(fechaCreacion, fechaResolucion);
        }
        return null;
    }
}
```

---

## üóÑÔ∏è Modelo de Datos

### üìä Diagrama Entidad-Relaci√≥n

```mermaid
erDiagram
    USUARIO ||--o{ TICKET : crea
    USUARIO ||--o{ NOTIFICACION : recibe
    USUARIO ||--o{ AUDITORIA : genera

    TECNICO ||--o{ TICKET : resuelve
    TECNICO ||--o{ ESTADISTICA_TECNICO : tiene
    TECNICO ||--o{ SOLICITUD_DEVOLUCION : solicita

    TICKET ||--o{ HISTORIAL_TICKET : tiene
    TICKET ||--o{ SOLICITUD_DEVOLUCION : puede_ser_devuelto

    ESTADISTICA_PERIODO ||--o{ ESTADISTICA_TECNICO : incluye

    USUARIO {
        int id PK
        string nombre
        string email
        string password_hash
        enum rol
        boolean activo
        datetime fecha_creacion
    }

    TICKET {
        int id PK
        int usuario_id FK
        int tecnico_id FK
        string titulo
        text descripcion
        enum estado
        enum prioridad
        datetime fecha_creacion
        datetime fecha_asignacion
        datetime fecha_resolucion
    }

    AUDITORIA {
        bigint id PK
        int id_usuario FK
        string nombre_usuario
        enum accion
        string entidad_tipo
        int entidad_id
        json valores_anteriores
        json valores_nuevos
        string ip_address
        text user_agent
        datetime fecha
    }

    NOTIFICACION {
        int id PK
        int usuario_id FK
        string titulo
        text mensaje
        enum tipo
        enum categoria
        enum estado
        enum prioridad
        datetime fecha_creacion
        datetime fecha_lectura
    }

    ESTADISTICA_PERIODO {
        int id PK
        enum periodo_tipo
        int anio
        int mes
        int tickets_creados
        int tickets_resueltos
        decimal tiempo_promedio_resolucion
        datetime calculado_en
    }
```

### üèóÔ∏è Patrones de Dise√±o en el Modelo

#### üéØ Aggregate Pattern
Los tickets funcionan como aggregates que encapsulan:
- El ticket principal (root)
- Su historial de cambios
- Sus notificaciones relacionadas

#### üíé Value Objects
```java
@Embeddable
public class DireccionIP {
    private String valor;

    // Validaci√≥n en el constructor
    public DireccionIP(String ip) {
        if (!isValidIP(ip)) {
            throw new IllegalArgumentException("IP inv√°lida: " + ip);
        }
        this.valor = ip;
    }

    private boolean isValidIP(String ip) {
        // Validaci√≥n de formato IPv4/IPv6
        return ip != null && IP_PATTERN.matcher(ip).matches();
    }
}
```

#### üîÑ State Pattern para Estados de Ticket
```java
public abstract class EstadoTicket {
    public abstract boolean puedeAsignarse();
    public abstract boolean puedeResolverse();
    public abstract boolean puedeReabrirse();

    public static class Pendiente extends EstadoTicket {
        public boolean puedeAsignarse() { return true; }
        public boolean puedeResolverse() { return false; }
        public boolean puedeReabrirse() { return false; }
    }

    public static class Asignado extends EstadoTicket {
        public boolean puedeAsignarse() { return false; }
        public boolean puedeResolverse() { return true; }
        public boolean puedeReabrirse() { return false; }
    }
}
```

---

## üîÑ Flujos de Datos

### üìù Flujo de Creaci√≥n de Ticket

```mermaid
sequenceDiagram
    participant C as Cliente
    participant Ctrl as Controller
    participant Srv as TicketService
    participant Repo as TicketRepository
    participant Aud as AuditoriaService
    participant Not as NotificacionService
    participant DB as Database

    C->>Ctrl: POST /api/v1/tickets
    Ctrl->>Ctrl: Validar JWT
    Ctrl->>Ctrl: Validar datos entrada
    Ctrl->>Srv: crearTicket(request)

    Srv->>Srv: Validar reglas negocio
    Srv->>Repo: save(ticket)
    Repo->>DB: INSERT ticket
    DB-->>Repo: ticket con ID
    Repo-->>Srv: ticket persistido

    Srv->>Aud: auditarCreacion(ticket)
    Aud->>DB: INSERT auditoria

    Srv->>Not: notificarNuevoTicket(ticket)
    Not->>DB: INSERT notificacion

    Srv-->>Ctrl: TicketDTO
    Ctrl-->>C: 201 Created + TicketDTO
```

### üîÑ Flujo de Asignaci√≥n de Ticket

```mermaid
sequenceDiagram
    participant A as Admin
    participant Ctrl as Controller
    participant Srv as TicketService
    participant TRepo as TicketRepository
    participant TecRepo as TecnicoRepository
    participant Aud as AuditoriaService
    participant Not as NotificacionService

    A->>Ctrl: PUT /api/v1/tickets/{id}/asignar
    Ctrl->>Srv: asignarTicket(ticketId, tecnicoId)

    Srv->>TRepo: findById(ticketId)
    Srv->>TecRepo: findById(tecnicoId)

    Srv->>Srv: Validar estado ticket
    Srv->>Srv: Validar disponibilidad t√©cnico

    Srv->>Srv: ticket.asignarATecnico(tecnico)
    Srv->>TRepo: save(ticket)

    Srv->>Aud: auditarAsignacion(ticket, tecnico)
    Srv->>Not: notificarAsignacion(ticket, tecnico)

    Srv-->>Ctrl: TicketDTO actualizado
    Ctrl-->>A: 200 OK + TicketDTO
```

### üìä Flujo de Generaci√≥n de Estad√≠sticas

```mermaid
sequenceDiagram
    participant Sched as Scheduler
    participant Srv as EstadisticaService
    participant TRepo as TicketRepository
    participant ERepo as EstadisticaRepository
    participant Cache as Redis Cache

    Sched->>Srv: calcularEstadisticasDiarias()

    Srv->>TRepo: obtenerTicketsPorFecha(fecha)
    TRepo-->>Srv: List<Ticket>

    Srv->>Srv: calcularMetricas(tickets)

    Srv->>ERepo: save(estadisticaPeriodo)

    Srv->>Cache: invalidar("estadisticas:*")

    Srv-->>Sched: Estad√≠sticas calculadas
```

---

## üîê Arquitectura de Seguridad

### üõ°Ô∏è Capas de Seguridad

```mermaid
graph TB
    subgraph "Security Layers"
        L1[1. Network Security<br/>HTTPS, WAF, DDoS Protection]
        L2[2. Authentication<br/>JWT, Session Management]
        L3[3. Authorization<br/>Role-based Access Control]
        L4[4. Input Validation<br/>Bean Validation, Sanitization]
        L5[5. Data Protection<br/>Encryption, Hashing]
        L6[6. Audit & Monitoring<br/>Security Events, Logging]
    end

    L1 --> L2
    L2 --> L3
    L3 --> L4
    L4 --> L5
    L5 --> L6
```

### üîë Arquitectura JWT

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                  HttpServletResponse response,
                                  FilterChain filterChain) throws ServletException, IOException {

        // 1. Extraer token del header Authorization
        String token = extractTokenFromRequest(request);

        if (token != null && jwtUtil.isTokenValid(token)) {
            // 2. Obtener usuario del token
            String username = jwtUtil.getUsernameFromToken(token);

            // 3. Cargar detalles del usuario
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            // 4. Crear objeto de autenticaci√≥n
            UsernamePasswordAuthenticationToken authentication =
                new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());

            // 5. Establecer en el contexto de seguridad
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }
}
```

### üîí Matriz de Autorizaci√≥n

| Recurso | TRABAJADOR | TECNICO | ADMIN | SUPER_ADMIN |
|---------|------------|---------|-------|-------------|
| **Tickets** |  |  |  |  |
| Crear | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Ver Propios | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Ver Todos | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| Asignar | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| Resolver | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ |
| **Usuarios** |  |  |  |  |
| Ver Perfil | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Editar Perfil | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| Gestionar Usuarios | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| **Estad√≠sticas** |  |  |  |  |
| Ver B√°sicas | ‚ùå | ‚úÖ | ‚úÖ | ‚úÖ |
| Ver Avanzadas | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| **Sistema** |  |  |  |  |
| Auditor√≠a | ‚ùå | ‚ùå | ‚úÖ | ‚úÖ |
| Configuraci√≥n | ‚ùå | ‚ùå | ‚ùå | ‚úÖ |

---

## üìä Arquitectura de Analytics

### üìà Pipeline de Datos

```mermaid
graph LR
    subgraph "Generaci√≥n de Eventos"
        A[Acciones de Usuario] --> B[Event Bus]
        C[Cambios de Estado] --> B
        D[M√©tricas Sistema] --> B
    end

    subgraph "Procesamiento"
        B --> E[Event Processor]
        E --> F[Data Aggregator]
        F --> G[Metric Calculator]
    end

    subgraph "Almacenamiento"
        G --> H[(Time Series DB)]
        G --> I[(Analytics DB)]
        G --> J[Cache Layer]
    end

    subgraph "Visualizaci√≥n"
        H --> K[Real-time Dashboard]
        I --> L[Historical Reports]
        J --> M[API Responses]
    end
```

### üìä M√©tricas Clave (KPIs)

#### üéØ M√©tricas de Negocio
```java
@Service
public class KPICalculatorService {

    public SLAReport calcularSLA(LocalDate inicio, LocalDate fin) {
        // Tiempo promedio de resoluci√≥n
        Duration tiempoPromedio = ticketRepository
            .calcularTiempoPromedioResolucion(inicio, fin);

        // Porcentaje de tickets resueltos en SLA (48 horas)
        double porcentajeSLA = ticketRepository
            .calcularPorcentajeTicketsEnSLA(inicio, fin, Duration.ofHours(48));

        // √çndice de satisfacci√≥n (simulado)
        double satisfaccion = calcularIndiceSatisfaccion(inicio, fin);

        return SLAReport.builder()
            .tiempoPromedioResolucion(tiempoPromedio)
            .porcentajeCumplimientoSLA(porcentajeSLA)
            .indiceSatisfaccion(satisfaccion)
            .build();
    }
}
```

#### üìä M√©tricas T√©cnicas
```java
@Component
public class TechnicalMetricsCollector {

    @EventListener
    public void onTicketCreated(TicketCreatedEvent event) {
        meterRegistry.counter("tickets.created",
            "priority", event.getTicket().getPrioridad().name(),
            "category", event.getTicket().getCategoria())
            .increment();
    }

    @EventListener
    public void onTicketResolved(TicketResolvedEvent event) {
        Duration resolutionTime = event.getResolutionTime();

        meterRegistry.timer("tickets.resolution.time")
            .record(resolutionTime);

        meterRegistry.counter("tickets.resolved",
            "technician", event.getTechnician().getNombre())
            .increment();
    }
}
```

---

## üöÄ Escalabilidad

### üìä Estrategias de Escalabilidad

#### üîÑ Escalabilidad Horizontal

**Stateless Design:**
```java
@RestController
@RequestMapping("/api/v1/tickets")
public class TicketController {

    // No hay estado en el controller
    // Toda la informaci√≥n viene del token JWT
    // El estado se mantiene en la base de datos

    @GetMapping("/{id}")
    public ResponseEntity<TicketDTO> obtenerTicket(
            @PathVariable Integer id,
            Authentication authentication) {

        // El estado del usuario viene del JWT
        String username = authentication.getName();
        Collection<String> roles = authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toList());

        return ResponseEntity.ok(ticketService.obtenerTicket(id, username, roles));
    }
}
```

**Load Testing Results:**
```
Concurrent Users: 1000
Duration: 10 minutes
Results:
- Average Response Time: 145ms
- 95th Percentile: 320ms
- 99th Percentile: 580ms
- Error Rate: 0.02%
- Throughput: 2,400 requests/second
```

#### üìà Escalabilidad Vertical

**JVM Tuning:**
```bash
# Configuraci√≥n optimizada para producci√≥n
JAVA_OPTS="-Xms2g -Xmx4g \
           -XX:+UseG1GC \
           -XX:MaxGCPauseMillis=200 \
           -XX:+UseStringDeduplication \
           -XX:+OptimizeStringConcat"
```

**Connection Pool Optimization:**
```properties
# HikariCP optimizado
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=300000
spring.datasource.hikari.max-lifetime=600000
spring.datasource.hikari.connection-timeout=20000
```

### üèóÔ∏è Arquitectura para Microservicios (Futuro)

```mermaid
graph TB
    subgraph "API Gateway"
        GW[Spring Cloud Gateway]
    end

    subgraph "Core Services"
        US[User Service]
        TS[Ticket Service]
        NS[Notification Service]
        AS[Analytics Service]
    end

    subgraph "Infrastructure"
        SR[Service Registry<br/>Eureka]
        CB[Circuit Breaker<br/>Hystrix]
        CF[Config Server]
    end

    subgraph "Data Layer"
        UDB[(User DB)]
        TDB[(Ticket DB)]
        ADB[(Analytics DB)]
        Cache[(Redis)]
    end

    subgraph "Message Bus"
        MQ[RabbitMQ/Kafka]
    end

    GW --> US
    GW --> TS
    GW --> NS
    GW --> AS

    US --> UDB
    TS --> TDB
    AS --> ADB

    US <--> Cache
    TS <--> Cache

    US --> MQ
    TS --> MQ
    NS <-- MQ
    AS <-- MQ

    US --> SR
    TS --> SR
    NS --> SR
    AS --> SR
```

---

## üîß Herramientas y Tecnolog√≠as

### üõ†Ô∏è Stack Tecnol√≥gico

| Capa | Tecnolog√≠a | Versi√≥n | Prop√≥sito |
|------|------------|---------|-----------|
| **Framework** | Spring Boot | 3.5.3 | Framework principal |
| **Lenguaje** | Java | 24 | Lenguaje de programaci√≥n |
| **Base de Datos** | MySQL | 8.0+ | Almacenamiento principal |
| **Cache** | Redis | 7.0+ | Cache distribuido |
| **Build Tool** | Maven | 3.9+ | Gesti√≥n de dependencias |
| **Testing** | JUnit 5 | 5.10+ | Testing framework |
| **Documentation** | OpenAPI/Swagger | 3.0 | Documentaci√≥n API |
| **Monitoring** | Micrometer | - | M√©tricas de aplicaci√≥n |
| **Security** | Spring Security | 6.0+ | Seguridad y autenticaci√≥n |

### üìä Herramientas de Desarrollo

- **IDE**: IntelliJ IDEA / VS Code
- **Database**: MySQL Workbench / phpMyAdmin
- **API Testing**: Postman / Insomnia
- **Load Testing**: JMeter / Artillery
- **Containerization**: Docker / Docker Compose
- **CI/CD**: GitHub Actions / Jenkins
- **Monitoring**: Prometheus + Grafana
- **Logging**: ELK Stack (Elasticsearch, Logstash, Kibana)

---

## üìù Decisiones Arquitect√≥nicas

### ü§î ADR (Architecture Decision Records)

#### ADR-001: Uso de Spring Boot
**Contexto**: Necesitamos un framework robusto para desarrollo r√°pido
**Decisi√≥n**: Usar Spring Boot 3.5.3
**Justificaci√≥n**:
- Ecosistema maduro
- Excelente soporte para microservicios
- Auto-configuraci√≥n
- Gran comunidad

#### ADR-002: Base de Datos Relacional
**Contexto**: Necesitamos consistencia de datos y transacciones ACID
**Decisi√≥n**: Usar MySQL 8.0
**Justificaci√≥n**:
- ACID compliance
- Soporte para JSON
- Rendimiento probado
- Tooling maduro

#### ADR-003: JWT para Autenticaci√≥n
**Contexto**: Necesitamos autenticaci√≥n stateless para escalabilidad
**Decisi√≥n**: Implementar JWT con RSA256
**Justificaci√≥n**:
- Stateless
- Escalable horizontalmente
- Est√°ndar de la industria
- Buena integraci√≥n con Spring Security

---

## üîÆ Roadmap Arquitect√≥nico

### üéØ Fase Actual: Monolito Modular
- ‚úÖ Arquitectura en capas bien definida
- ‚úÖ Separaci√≥n clara de responsabilidades
- ‚úÖ Preparado para microservicios

### üöÄ Pr√≥xima Fase: Event-Driven Architecture
- üìÖ Implementar Message Bus (RabbitMQ/Kafka)
- üìÖ Event Sourcing para auditor√≠a
- üìÖ CQRS completo con diferentes stores

### üåü Fase Final: Microservicios
- üìÖ Separaci√≥n en servicios independientes
- üìÖ API Gateway con Spring Cloud Gateway
- üìÖ Service Discovery con Eureka
- üìÖ Circuit Breakers con Hystrix

---

## üìû Contacto y Soporte

Para preguntas sobre la arquitectura:
- **Arquitecto Principal**: Sebastian Kc
- **Email**: akc9912@gmail.com
- **GitHub**: [@Akc9912](https://github.com/Akc9912)
